ğŸ“± ì•±ê°œë°œíŒ€ ì—…ë¬´ (ë…¹ì·¨íŒŒì¼ ìë™ ì—…ë¡œë“œ + UI ì—°ë™)
1. ë°±ê·¸ë¼ìš´ë“œ ë…¹ì·¨íŒŒì¼ ìë™ ìˆ˜ì§‘ ë° ì—…ë¡œë“œ
1-1. ë…¹ì·¨íŒŒì¼ ìŠ¤ìºë„ˆ
kotlinclass RecordingAutoCollector {
    
    // ì£¼ìš” ì œì¡°ì‚¬ë³„ ë…¹ìŒ íŒŒì¼ ê²½ë¡œ
    private val RECORDING_PATHS = arrayOf(
        "/storage/emulated/0/Call recordings/",
        "/storage/emulated/0/Recordings/Call/",
        "/storage/emulated/0/MIUI/sound_recorder/call_rec/",  // ìƒ¤ì˜¤ë¯¸
        "/storage/emulated/0/SamsungRecorder/Call/",          // ì‚¼ì„±
        "/storage/emulated/0/recorder/call/",                 // LG
    )
    
    fun scanTodaysRecordings(): List<RecordingFile> {
        val today = System.currentTimeMillis()
        val oneDayAgo = today - (24 * 60 * 60 * 1000)
        
        return RECORDING_PATHS.flatMap { path ->
            scanDirectory(path, oneDayAgo)
        }.distinctBy { it.filePath }
    }
    
    private fun scanDirectory(path: String, sinceTime: Long): List<RecordingFile> {
        val directory = File(path)
        if (!directory.exists()) return emptyList()
        
        return directory.walkTopDown()
            .filter { file ->
                file.isFile && 
                file.lastModified() >= sinceTime &&
                file.extension.lowercase() in arrayOf("mp3", "m4a", "amr", "3gp", "wav")
            }
            .map { file ->
                RecordingFile(
                    fileName = file.name,
                    filePath = file.absolutePath,
                    fileSize = file.length(),
                    lastModified = file.lastModified(),
                    phoneNumber = extractPhoneFromFileName(file.name) // íŒŒì¼ëª…ì—ì„œ ë²ˆí˜¸ ì¶”ì¶œ
                )
            }.toList()
    }
}
1-2. í†µí™”ê¸°ë¡ê³¼ ë§¤ì¹­
kotlinclass CallRecordingMatcher {
    
    fun matchRecordingsWithCalls(recordings: List<RecordingFile>): List<MatchedCall> {
        val callLogs = getRecentCallLogs()
        val matched = mutableListOf<MatchedCall>()
        
        recordings.forEach { recording ->
            val callLog = findMatchingCall(recording, callLogs)
            if (callLog != null) {
                matched.add(MatchedCall(recording, callLog))
            } else {
                // í†µí™”ê¸°ë¡ì´ ì—†ì–´ë„ íŒŒì¼ëª…ì—ì„œ ë²ˆí˜¸ë¥¼ ì¶”ì¶œí–ˆë‹¤ë©´ ì—…ë¡œë“œ
                if (recording.phoneNumber != null) {
                    matched.add(MatchedCall(recording, null))
                }
            }
        }
        
        return matched
    }
    
    private fun findMatchingCall(recording: RecordingFile, callLogs: List<CallLog>): CallLog? {
        val recordingTime = recording.lastModified
        
        return callLogs.find { call ->
            val timeDiff = abs(call.timestamp - recordingTime)
            val phoneMatch = recording.phoneNumber?.contains(call.phoneNumber) == true ||
                           call.phoneNumber.contains(recording.phoneNumber ?: "")
            
            timeDiff <= 300000 && phoneMatch // 5ë¶„ ì˜¤ì°¨ + ë²ˆí˜¸ ë§¤ì¹­
        }
    }
}
1-3. ìë™ ì—…ë¡œë“œ ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤
kotlinclass AutoUploadService : Service() {
    
    private val uploadHandler = Handler(Looper.getMainLooper())
    private val uploadRunnable = object : Runnable {
        override fun run() {
            performAutoUpload()
            uploadHandler.postDelayed(this, 600000) // 10ë¶„ë§ˆë‹¤ ì‹¤í–‰
        }
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForegroundService()
        uploadHandler.post(uploadRunnable)
        return START_STICKY
    }
    
    private fun performAutoUpload() {
        try {
            val recordings = RecordingAutoCollector().scanTodaysRecordings()
            val matched = CallRecordingMatcher().matchRecordingsWithCalls(recordings)
            
            matched.forEach { matchedCall ->
                if (!isAlreadyUploaded(matchedCall.recording)) {
                    uploadRecordingToServer(matchedCall)
                }
            }
            
        } catch (e: Exception) {
            Log.e("AutoUpload", "ìë™ ì—…ë¡œë“œ ì‹¤íŒ¨", e)
        }
    }
}
2. ê³ ê°ê²€ìƒ‰ ë¦¬ìŠ¤íŠ¸ UI ìˆ˜ì •
2-1. ê³ ê° ì•„ì´í…œì— ë…¹ì·¨ ì•„ì´ì½˜ ì¶”ê°€
kotlin// CustomerListAdapter.kt
class CustomerListAdapter : RecyclerView.Adapter<CustomerViewHolder>() {
    
    override fun onBindViewHolder(holder: CustomerViewHolder, position: Int) {
        val customer = customers[position]
        
        holder.bind(customer)
        
        // ë…¹ì·¨íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ ì²´í¬ ë° ì•„ì´ì½˜ í‘œì‹œ
        checkRecordingExists(customer.phoneNumber) { hasRecording ->
            holder.showRecordingIcon(hasRecording)
        }
    }
}

class CustomerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    private val recordingIcon: ImageView = itemView.findViewById(R.id.iv_recording_icon)
    
    fun bind(customer: Customer) {
        // ê¸°ì¡´ ê³ ê° ì •ë³´ ë°”ì¸ë”©
        itemView.findViewById<TextView>(R.id.tv_customer_name).text = customer.name
        itemView.findViewById<TextView>(R.id.tv_phone_number).text = customer.phoneNumber
        // ... ê¸°íƒ€ ì •ë³´
    }
    
    fun showRecordingIcon(hasRecording: Boolean) {
        recordingIcon.visibility = if (hasRecording) View.VISIBLE else View.GONE
        
        if (hasRecording) {
            recordingIcon.setOnClickListener {
                openRecordingPlayer(customer.phoneNumber)
            }
        }
    }
    
    private fun openRecordingPlayer(phoneNumber: String) {
        // í•´ë‹¹ ë²ˆí˜¸ì˜ ë…¹ì·¨íŒŒì¼ì„ íœ´ëŒ€í° ê¸°ë³¸ í”Œë ˆì´ì–´ë¡œ ì¬ìƒ
        findAndPlayRecording(phoneNumber)
    }
}
2-2. ê³ ê°ê²€ìƒ‰ í™”ë©´ ë ˆì´ì•„ì›ƒ ìˆ˜ì •
xml<!-- customer_list_item.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp">
    
    <!-- ê¸°ì¡´ ê³ ê° ì •ë³´ -->
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">
        
        <TextView
            android:id="@+id/tv_customer_name"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textStyle="bold" />
            
        <TextView
            android:id="@+id/tv_phone_number"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp" />
            
        <TextView
            android:id="@+id/tv_last_contact"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="#666666" />
    </LinearLayout>
    
    <!-- ë…¹ì·¨ ì•„ì´ì½˜ -->
    <ImageView
        android:id="@+id/iv_recording_icon"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="8dp"
        android:src="@drawable/ic_recording"
        android:visibility="gone"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:padding="4dp" />
        
</LinearLayout>
2-3. ë…¹ì·¨íŒŒì¼ ì¬ìƒ ê¸°ëŠ¥
kotlinclass RecordingPlayerHelper {
    
    fun findAndPlayRecording(phoneNumber: String) {
        // í•´ë‹¹ ë²ˆí˜¸ì˜ ë…¹ì·¨íŒŒì¼ ê²€ìƒ‰
        val recordingFile = findLatestRecording(phoneNumber)
        
        if (recordingFile != null) {
            playWithSystemPlayer(recordingFile)
        } else {
            // ì„œë²„ì—ì„œ ë‹¤ìš´ë¡œë“œ í›„ ì¬ìƒ (ì˜µì…˜)
            downloadAndPlay(phoneNumber)
        }
    }
    
    private fun findLatestRecording(phoneNumber: String): File? {
        val recordings = RecordingAutoCollector().scanAllRecordings()
        
        return recordings
            .filter { it.phoneNumber?.contains(phoneNumber) == true }
            .sortedByDescending { it.lastModified }
            .firstOrNull()
            ?.let { File(it.filePath) }
    }
    
    private fun playWithSystemPlayer(audioFile: File) {
        try {
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(
                    FileProvider.getUriForFile(
                        context,
                        "${context.packageName}.fileprovider",
                        audioFile
                    ),
                    "audio/*"
                )
                flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
            }
            
            context.startActivity(intent)
            
        } catch (e: Exception) {
            Log.e("RecordingPlayer", "ì¬ìƒ ì‹¤íŒ¨", e)
            Toast.makeText(context, "ë…¹ì·¨ ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun downloadAndPlay(phoneNumber: String) {
        // ì„œë²„ì—ì„œ í•´ë‹¹ ë²ˆí˜¸ì˜ ìµœì‹  ë…¹ì·¨íŒŒì¼ ë‹¤ìš´ë¡œë“œ
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val recording = ApiService.getLatestRecording(phoneNumber)
                if (recording != null) {
                    val downloadedFile = downloadRecording(recording.id)
                    withContext(Dispatchers.Main) {
                        playWithSystemPlayer(downloadedFile)
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(context, "ë…¹ì·¨ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
}
3. ë…¹ì·¨íŒŒì¼ ìƒíƒœ ê´€ë¦¬
3-1. ë¡œì»¬ ë…¹ì·¨ ë°ì´í„°ë² ì´ìŠ¤
kotlin@Entity(tableName = "local_recordings")
data class LocalRecording(
    @PrimaryKey val id: String,
    val phoneNumber: String,
    val filePath: String,
    val fileName: String,
    val fileSize: Long,
    val recordedAt: Long,
    val isUploaded: Boolean = false,
    val serverId: String? = null
)

@Dao
interface LocalRecordingDao {
    @Query("SELECT * FROM local_recordings WHERE phoneNumber LIKE '%' || :phoneNumber || '%'")
    suspend fun getRecordingsByPhone(phoneNumber: String): List<LocalRecording>
    
    @Query("SELECT EXISTS(SELECT 1 FROM local_recordings WHERE phoneNumber LIKE '%' || :phoneNumber || '%')")
    suspend fun hasRecordingForPhone(phoneNumber: String): Boolean
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRecording(recording: LocalRecording)
    
    @Query("UPDATE local_recordings SET isUploaded = 1, serverId = :serverId WHERE id = :id")
    suspend fun markAsUploaded(id: String, serverId: String)
}
3-2. ë…¹ì·¨íŒŒì¼ ìºì‹œ ê´€ë¦¬
kotlinclass RecordingCacheManager {
    
    fun checkRecordingExists(phoneNumber: String, callback: (Boolean) -> Unit) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // ë¡œì»¬ íŒŒì¼ í™•ì¸
                val hasLocal = localRecordingDao.hasRecordingForPhone(phoneNumber)
                
                if (hasLocal) {
                    withContext(Dispatchers.Main) {
                        callback(true)
                    }
                } else {
                    // ì„œë²„ì—ì„œ í™•ì¸
                    val hasServer = ApiService.hasRecordingForPhone(phoneNumber)
                    withContext(Dispatchers.Main) {
                        callback(hasServer)
                    }
                }
                
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    callback(false)
                }
            }
        }
    }
}
4. FileProvider ì„¤ì •
4-1. AndroidManifest.xml
xml<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="${applicationId}.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>
4-2. file_paths.xml
xml<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="external_files" path="." />
    <files-path name="internal_files" path="." />
    <cache-path name="cache_files" path="." />
</paths>
ğŸ“‹ ì•±ê°œë°œíŒ€ ì£¼ìš” ì‘ì—… ë¦¬ìŠ¤íŠ¸
ìš°ì„ ìˆœìœ„ 1 (í•µì‹¬ ê¸°ëŠ¥)

âœ… ë°±ê·¸ë¼ìš´ë“œ ë…¹ì·¨íŒŒì¼ ìë™ ìŠ¤ìº” ì‹œìŠ¤í…œ
âœ… í†µí™”ê¸°ë¡ê³¼ ë…¹ì·¨íŒŒì¼ ë§¤ì¹­ ë¡œì§
âœ… ìë™ ì—…ë¡œë“œ ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤
âœ… ê³ ê°ë¦¬ìŠ¤íŠ¸ UIì— ë…¹ì·¨ ì•„ì´ì½˜ ì¶”ê°€

ìš°ì„ ìˆœìœ„ 2 (ì‚¬ìš©ì ê²½í—˜)

âœ… íœ´ëŒ€í° ê¸°ë³¸ í”Œë ˆì´ì–´ë¡œ ë…¹ì·¨ ì¬ìƒ
âœ… ë¡œì»¬ ë…¹ì·¨ ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬
âœ… ë…¹ì·¨íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ ë¹ ë¥¸ ì²´í¬
âœ… FileProvider ì„¤ì •

ìš°ì„ ìˆœìœ„ 3 (ìµœì í™”)

âœ… ì—…ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë¡œì§
âœ… ì¤‘ë³µ ì—…ë¡œë“œ ë°©ì§€
âœ… ë„¤íŠ¸ì›Œí¬ ìƒíƒœë³„ ì—…ë¡œë“œ ì „ëµ
âœ… ë°°í„°ë¦¬ ìµœì í™”