📱 앱개발팀 업무 (녹취파일 자동 업로드 + UI 연동)
1. 백그라운드 녹취파일 자동 수집 및 업로드
1-1. 녹취파일 스캐너
kotlinclass RecordingAutoCollector {
    
    // 주요 제조사별 녹음 파일 경로
    private val RECORDING_PATHS = arrayOf(
        "/storage/emulated/0/Call recordings/",
        "/storage/emulated/0/Recordings/Call/",
        "/storage/emulated/0/MIUI/sound_recorder/call_rec/",  // 샤오미
        "/storage/emulated/0/SamsungRecorder/Call/",          // 삼성
        "/storage/emulated/0/recorder/call/",                 // LG
    )
    
    fun scanTodaysRecordings(): List<RecordingFile> {
        val today = System.currentTimeMillis()
        val oneDayAgo = today - (24 * 60 * 60 * 1000)
        
        return RECORDING_PATHS.flatMap { path ->
            scanDirectory(path, oneDayAgo)
        }.distinctBy { it.filePath }
    }
    
    private fun scanDirectory(path: String, sinceTime: Long): List<RecordingFile> {
        val directory = File(path)
        if (!directory.exists()) return emptyList()
        
        return directory.walkTopDown()
            .filter { file ->
                file.isFile && 
                file.lastModified() >= sinceTime &&
                file.extension.lowercase() in arrayOf("mp3", "m4a", "amr", "3gp", "wav")
            }
            .map { file ->
                RecordingFile(
                    fileName = file.name,
                    filePath = file.absolutePath,
                    fileSize = file.length(),
                    lastModified = file.lastModified(),
                    phoneNumber = extractPhoneFromFileName(file.name) // 파일명에서 번호 추출
                )
            }.toList()
    }
}
1-2. 통화기록과 매칭
kotlinclass CallRecordingMatcher {
    
    fun matchRecordingsWithCalls(recordings: List<RecordingFile>): List<MatchedCall> {
        val callLogs = getRecentCallLogs()
        val matched = mutableListOf<MatchedCall>()
        
        recordings.forEach { recording ->
            val callLog = findMatchingCall(recording, callLogs)
            if (callLog != null) {
                matched.add(MatchedCall(recording, callLog))
            } else {
                // 통화기록이 없어도 파일명에서 번호를 추출했다면 업로드
                if (recording.phoneNumber != null) {
                    matched.add(MatchedCall(recording, null))
                }
            }
        }
        
        return matched
    }
    
    private fun findMatchingCall(recording: RecordingFile, callLogs: List<CallLog>): CallLog? {
        val recordingTime = recording.lastModified
        
        return callLogs.find { call ->
            val timeDiff = abs(call.timestamp - recordingTime)
            val phoneMatch = recording.phoneNumber?.contains(call.phoneNumber) == true ||
                           call.phoneNumber.contains(recording.phoneNumber ?: "")
            
            timeDiff <= 300000 && phoneMatch // 5분 오차 + 번호 매칭
        }
    }
}
1-3. 자동 업로드 백그라운드 서비스
kotlinclass AutoUploadService : Service() {
    
    private val uploadHandler = Handler(Looper.getMainLooper())
    private val uploadRunnable = object : Runnable {
        override fun run() {
            performAutoUpload()
            uploadHandler.postDelayed(this, 600000) // 10분마다 실행
        }
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForegroundService()
        uploadHandler.post(uploadRunnable)
        return START_STICKY
    }
    
    private fun performAutoUpload() {
        try {
            val recordings = RecordingAutoCollector().scanTodaysRecordings()
            val matched = CallRecordingMatcher().matchRecordingsWithCalls(recordings)
            
            matched.forEach { matchedCall ->
                if (!isAlreadyUploaded(matchedCall.recording)) {
                    uploadRecordingToServer(matchedCall)
                }
            }
            
        } catch (e: Exception) {
            Log.e("AutoUpload", "자동 업로드 실패", e)
        }
    }
}
2. 고객검색 리스트 UI 수정
2-1. 고객 아이템에 녹취 아이콘 추가
kotlin// CustomerListAdapter.kt
class CustomerListAdapter : RecyclerView.Adapter<CustomerViewHolder>() {
    
    override fun onBindViewHolder(holder: CustomerViewHolder, position: Int) {
        val customer = customers[position]
        
        holder.bind(customer)
        
        // 녹취파일 존재 여부 체크 및 아이콘 표시
        checkRecordingExists(customer.phoneNumber) { hasRecording ->
            holder.showRecordingIcon(hasRecording)
        }
    }
}

class CustomerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    private val recordingIcon: ImageView = itemView.findViewById(R.id.iv_recording_icon)
    
    fun bind(customer: Customer) {
        // 기존 고객 정보 바인딩
        itemView.findViewById<TextView>(R.id.tv_customer_name).text = customer.name
        itemView.findViewById<TextView>(R.id.tv_phone_number).text = customer.phoneNumber
        // ... 기타 정보
    }
    
    fun showRecordingIcon(hasRecording: Boolean) {
        recordingIcon.visibility = if (hasRecording) View.VISIBLE else View.GONE
        
        if (hasRecording) {
            recordingIcon.setOnClickListener {
                openRecordingPlayer(customer.phoneNumber)
            }
        }
    }
    
    private fun openRecordingPlayer(phoneNumber: String) {
        // 해당 번호의 녹취파일을 휴대폰 기본 플레이어로 재생
        findAndPlayRecording(phoneNumber)
    }
}
2-2. 고객검색 화면 레이아웃 수정
xml<!-- customer_list_item.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp">
    
    <!-- 기존 고객 정보 -->
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">
        
        <TextView
            android:id="@+id/tv_customer_name"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textStyle="bold" />
            
        <TextView
            android:id="@+id/tv_phone_number"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp" />
            
        <TextView
            android:id="@+id/tv_last_contact"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="#666666" />
    </LinearLayout>
    
    <!-- 녹취 아이콘 -->
    <ImageView
        android:id="@+id/iv_recording_icon"
        android:layout_width="32dp"
        android:layout_height="32dp"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="8dp"
        android:src="@drawable/ic_recording"
        android:visibility="gone"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:padding="4dp" />
        
</LinearLayout>
2-3. 녹취파일 재생 기능
kotlinclass RecordingPlayerHelper {
    
    fun findAndPlayRecording(phoneNumber: String) {
        // 해당 번호의 녹취파일 검색
        val recordingFile = findLatestRecording(phoneNumber)
        
        if (recordingFile != null) {
            playWithSystemPlayer(recordingFile)
        } else {
            // 서버에서 다운로드 후 재생 (옵션)
            downloadAndPlay(phoneNumber)
        }
    }
    
    private fun findLatestRecording(phoneNumber: String): File? {
        val recordings = RecordingAutoCollector().scanAllRecordings()
        
        return recordings
            .filter { it.phoneNumber?.contains(phoneNumber) == true }
            .sortedByDescending { it.lastModified }
            .firstOrNull()
            ?.let { File(it.filePath) }
    }
    
    private fun playWithSystemPlayer(audioFile: File) {
        try {
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(
                    FileProvider.getUriForFile(
                        context,
                        "${context.packageName}.fileprovider",
                        audioFile
                    ),
                    "audio/*"
                )
                flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
            }
            
            context.startActivity(intent)
            
        } catch (e: Exception) {
            Log.e("RecordingPlayer", "재생 실패", e)
            Toast.makeText(context, "녹취 재생에 실패했습니다", Toast.LENGTH_SHORT).show()
        }
    }
    
    private fun downloadAndPlay(phoneNumber: String) {
        // 서버에서 해당 번호의 최신 녹취파일 다운로드
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val recording = ApiService.getLatestRecording(phoneNumber)
                if (recording != null) {
                    val downloadedFile = downloadRecording(recording.id)
                    withContext(Dispatchers.Main) {
                        playWithSystemPlayer(downloadedFile)
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(context, "녹취를 찾을 수 없습니다", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
}
3. 녹취파일 상태 관리
3-1. 로컬 녹취 데이터베이스
kotlin@Entity(tableName = "local_recordings")
data class LocalRecording(
    @PrimaryKey val id: String,
    val phoneNumber: String,
    val filePath: String,
    val fileName: String,
    val fileSize: Long,
    val recordedAt: Long,
    val isUploaded: Boolean = false,
    val serverId: String? = null
)

@Dao
interface LocalRecordingDao {
    @Query("SELECT * FROM local_recordings WHERE phoneNumber LIKE '%' || :phoneNumber || '%'")
    suspend fun getRecordingsByPhone(phoneNumber: String): List<LocalRecording>
    
    @Query("SELECT EXISTS(SELECT 1 FROM local_recordings WHERE phoneNumber LIKE '%' || :phoneNumber || '%')")
    suspend fun hasRecordingForPhone(phoneNumber: String): Boolean
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRecording(recording: LocalRecording)
    
    @Query("UPDATE local_recordings SET isUploaded = 1, serverId = :serverId WHERE id = :id")
    suspend fun markAsUploaded(id: String, serverId: String)
}
3-2. 녹취파일 캐시 관리
kotlinclass RecordingCacheManager {
    
    fun checkRecordingExists(phoneNumber: String, callback: (Boolean) -> Unit) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // 로컬 파일 확인
                val hasLocal = localRecordingDao.hasRecordingForPhone(phoneNumber)
                
                if (hasLocal) {
                    withContext(Dispatchers.Main) {
                        callback(true)
                    }
                } else {
                    // 서버에서 확인
                    val hasServer = ApiService.hasRecordingForPhone(phoneNumber)
                    withContext(Dispatchers.Main) {
                        callback(hasServer)
                    }
                }
                
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    callback(false)
                }
            }
        }
    }
}
4. FileProvider 설정
4-1. AndroidManifest.xml
xml<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="${applicationId}.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>
4-2. file_paths.xml
xml<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="external_files" path="." />
    <files-path name="internal_files" path="." />
    <cache-path name="cache_files" path="." />
</paths>
📋 앱개발팀 주요 작업 리스트
우선순위 1 (핵심 기능)

✅ 백그라운드 녹취파일 자동 스캔 시스템
✅ 통화기록과 녹취파일 매칭 로직
✅ 자동 업로드 백그라운드 서비스
✅ 고객리스트 UI에 녹취 아이콘 추가

우선순위 2 (사용자 경험)

✅ 휴대폰 기본 플레이어로 녹취 재생
✅ 로컬 녹취 데이터베이스 관리
✅ 녹취파일 존재 여부 빠른 체크
✅ FileProvider 설정

우선순위 3 (최적화)

✅ 업로드 실패 시 재시도 로직
✅ 중복 업로드 방지
✅ 네트워크 상태별 업로드 전략
✅ 배터리 최적화